import { AuditModel } from "../models/AuditModel.js";
import { Assignment } from "../schemas/Assignment.js";
import { InitialConsultations } from "../schemas/Initial_Consultations.js";
import { User } from "../schemas/User.js";
import { InternalUser } from "../schemas/Internal_User.js";
import { sequelize } from "../database/database.js"; // Necesario para transacciones
import { Op } from 'sequelize'; // Necesario para operadores como 'in'

export class AssignmentModel {

    static async getAll() {
        try {
            return await Assignment.findAll();
        } catch (error) {
            throw new Error(`Error retrieving assignments: ${error.message}`);
        }
    }

    static async getAllWithDetails() {
        try {
            return await Assignment.findAll({
                include: [
                    {
                        model: InitialConsultations, // Fetches the related InitialConsultation
                        attributes: ['Init_Code', 'Init_Subject', 'User_ID'], // Specify needed attributes
                        required: true, // Optional: Makes it an INNER JOIN
                        include: [
                            {
                                model: User, // Fetches the User related to the InitialConsultation
                                attributes: [
                                    'User_ID',
                                    'User_FirstName',
                                    'User_LastName',
                                ],
                                required: true // Optional: Makes it an INNER JOIN
                            }
                        ]
                    },
                    {
                        model: InternalUser, // Fetches the InternalUser who assigned the case
                        as: 'Assigner', 
                        attributes: ['Internal_ID', 'Internal_Name', 'Internal_LastName'], 
                        required: false 
                    },
                    {
                        model: InternalUser, // Fetches the InternalUser who is the student
                        as: 'Student', 
                        attributes: ['Internal_ID', 'Internal_Name', 'Internal_LastName'], 
                        required: false 
                    }
                ],
                order: [['Assignment_Date', 'DESC']] 
            });
        } catch (error) {
            console.error("Error retrieving assignments with details:", error);
            // Check if the error is specifically about associations or fields
            if (error.message.includes('is not associated') || error.message.includes('Unknown column')) {
                 console.error("Potential issue with Sequelize associations or model attributes. Verify associations in schema files.");
            }
            throw new Error(`Error retrieving assignments with details: ${error.message}`);
        }
    }








    static async getById(id) {
        try {
            return await Assignment.findOne({
                where: { Assignment_Id: id }
            });
        } catch (error) {
            throw new Error(`Error retrieving assignment: ${error.message}`);
        }
    }

    static async getByStudentId(studentId) {
        try {
            return await Assignment.findAll({
                where: { Internal_User_ID_Student: studentId }
            });
        } catch (error) {
            throw new Error(`Error retrieving assignments for student ID ${studentId}: ${error.message}`);
        }
    }

    static async getStudentByInitCode(initCode) {
        try {
            const assignment = await Assignment.findOne({
                where: { Init_Code: initCode },
                attributes: ['Internal_User_ID_Student'],
            });

            if (assignment) {
                return assignment.Internal_User_ID_Student;
            } else {
                return null;
            }
        } catch (error) {
            throw new Error(`Error al buscar el estudiante por c칩digo de consulta inicial: ${error.message}`);
        }
    }

    static async getByInitCode(initCode) {
        try {
            return await Assignment.findOne({
                where: { Init_Code: initCode }
            });
        } catch (error) {
            throw new Error(`Error retrieving assignment by Init_Code: ${error.message}`);
        }
    }

    static async create(data, internalUser) {
        try {
            const newAssignment = await Assignment.create(data);
            const internalId = internalUser || getUserId();

            // 游댳 Registrar en Audit que un usuario interno cre칩 una asignaci칩n
            await AuditModel.registerAudit(
                internalId, 
                "INSERT",
                "Assignment",
                `El usuario interno ${internalId} cre칩 la asignaci칩n con ID ${newAssignment.Assignment_ID}`
            );

            return newAssignment;
        } catch (error) {
            throw new Error(`Error creating assignment: ${error.message}`);
        }
    }

    /**
     * Asigna casos pendientes ("Por Asignar") de un 치rea espec칤fica
     * de forma equitativa a los estudiantes activos de esa misma 치rea,
     * **considerando la carga de trabajo actual de cada estudiante para nivelar**.
     * @param {string} area - El 치rea (materia) de los casos y estudiantes.
     * @param {string} assignerInternalId - El ID del usuario interno que realiza la asignaci칩n.
     * @returns {Promise<object>} - Objeto con mensaje y las asignaciones creadas.
     */
    static async assignPendingCasesByAreaEquitably(area, assignerInternalId) {
        const t = await sequelize.transaction();
        try {
            const loggedInUserId = assignerInternalId;
            if (!loggedInUserId) {
                throw new Error("El ID del usuario asignador es requerido.");
            }

            // 1. Encontrar casos "Por Asignar" del 치rea
            const pendingCases = await InitialConsultations.findAll({
                where: { Init_Type: "Por Asignar", Init_Subject: area },
                attributes: ['Init_Code'],
                transaction: t
            });

            if (!pendingCases || pendingCases.length === 0) {
                await t.rollback();
                return { message: `No hay casos 'Por Asignar' en el 치rea ${area}.`, assignments: [] };
            }
            const caseCodes = pendingCases.map(c => c.Init_Code);
            const numberOfCasesToAssign = caseCodes.length;

            // 2. Encontrar estudiantes activos del 치rea
            const activeStudents = await InternalUser.findAll({
                where: {
                    Internal_Type: "Estudiante",
                    Internal_Status: 'Activo',
                    Internal_Area: area
                },
                attributes: ['Internal_ID'],
                transaction: t
            });

            if (!activeStudents || activeStudents.length === 0) {
                await t.rollback();
                const error = new Error(`No se encontraron estudiantes activos en el 치rea ${area} para asignar los casos.`);
                error.statusCode = 404;
                throw error;
            }
            const studentIds = activeStudents.map(s => s.Internal_ID);

            // 3. Contar asignaciones actuales por estudiante activo de esa 치rea
            const currentAssignmentsCount = await Assignment.findAll({
                attributes: [
                    'Internal_User_ID_Student',
                    [sequelize.fn('COUNT', sequelize.col('Assignment_Id')), 'count']
                ],
                where: {
                    Internal_User_ID_Student: {
                        [Op.in]: studentIds
                    }
                    // Podr칤as a침adir filtros adicionales si solo cuentan ciertos tipos de asignaciones (ej. activas)
                },
                group: ['Internal_User_ID_Student'],
                raw: true, // Devuelve objetos planos
                transaction: t
            });

            // Crear un mapa para f치cil acceso a las cuentas: { studentId: count }
            const studentCountsMap = new Map(studentIds.map(id => [id, 0])); // Inicializar todos con 0
            currentAssignmentsCount.forEach(item => {
                studentCountsMap.set(item.Internal_User_ID_Student, parseInt(item.count, 10));
            });

            // Convertir a un array de objetos para poder ordenar: [{ studentId: 'id1', count: 5 }, ...]
            let studentData = studentIds.map(id => ({
                studentId: id,
                count: studentCountsMap.get(id)
            }));

            // 4. L칩gica de asignaci칩n priorizando a los que tienen menos
            const assignmentsToCreate = [];
            const assignmentDate = new Date();

            for (let i = 0; i < numberOfCasesToAssign; i++) {
                // Ordenar a los estudiantes por su cuenta actual (ascendente) ANTES de cada asignaci칩n
                studentData.sort((a, b) => a.count - b.count);

                // El estudiante al que se le asignar치 es el primero en la lista ordenada (el que tiene menos)
                const targetStudent = studentData[0];

                assignmentsToCreate.push({
                    Init_Code: caseCodes[i],
                    Internal_User_ID_Student: targetStudent.studentId,
                    Assignment_Date: assignmentDate,
                    Internal_User_ID: loggedInUserId
                });

                // Incrementar la cuenta del estudiante que acaba de recibir el caso (en nuestra estructura en memoria)
                targetStudent.count++;
            }

            // 5. Crear las asignaciones en la BD
            const createdAssignments = await Assignment.bulkCreate(assignmentsToCreate, { transaction: t });

            // 6. Actualizar el estado de los casos a "Asignado"
            await InitialConsultations.update(
                { Init_Type: "Asignado" },
                {
                    where: { Init_Code: { [Op.in]: caseCodes } },
                    transaction: t
                }
            );

            // 7. Registrar Auditor칤a
            await AuditModel.registerAudit(
                loggedInUserId,
                "BULK_ASSIGN_EQU", // Acci칩n espec칤fica para asignaci칩n masiva EQUITATIVA
                "Assignment/InitialConsultations",
                `El usuario interno ${loggedInUserId} asign칩 ${caseCodes.length} casos del 치rea ${area} equitativamente (nivelando carga).`,
                { transaction: t }
            );

            // 8. Confirmar la transacci칩n
            await t.commit();

            return {
                message: `Se asignaron ${createdAssignments.length} casos del 치rea ${area} exitosamente, nivelando la carga existente.`,
                assignments: createdAssignments
            };

        } catch (error) {
            await t.rollback();
            console.error("Error en la asignaci칩n equitativa (nivelada) de casos:", error);
            throw error; // Re-lanzar para que el controlador lo maneje
        }
    }

    static async update(id, data, internalUser) {
        try {
            const assignment = await this.getById(id);
            
            if (!assignment) return null;

            const internalId = internalUser || getUserId();

            const [rowsUpdated] = await Assignment.update(data, {
                where: { Assignment_Id: id }
            });

            if (rowsUpdated === 0) return null;

            const updatedAssignment = await this.getById(id);

            // 游댳 Registrar en Audit que un usuario interno actualiz칩 una asignaci칩n
            await AuditModel.registerAudit(
                internalId, 
                "UPDATE",
                "Assignment",
                `El usuario interno ${internalId} actualiz칩 la asignaci칩n con ID ${id}`
            );

            return updatedAssignment;
        } catch (error) {
            throw new Error(`Error updating assignment: ${error.message}`);
        }
    }

    /**
     * Actualiza una asignaci칩n buscando por Init_Code.
     * @param {string} initCode - El c칩digo de la consulta inicial (caso) que viene como par치metro.
     * @param {object} data - Los datos a actualizar en la asignaci칩n (del body de la request).
     * @param {string} internalUserId - El ID del usuario interno que realiza la acci칩n (del header).
     * @returns {Promise<Assignment|null>} - La asignaci칩n actualizada o null si no se encuentra o no se actualiza.
     */
    static async updateByInitCode(initCode, data, internalUserId) {
        try {
            // 1. Buscar la asignaci칩n existente usando el nombre de la clase
            const assignment = await AssignmentModel.getByInitCode(initCode); // <--- CORRECCI칍N AQU칈

            // 2. Si no se encuentra, retornar null
            if (!assignment) {
                console.log(`Asignaci칩n con Init_Code ${initCode} no encontrada.`);
                return null;
            }

            // 3. Obtener el ID del usuario para auditor칤a (viene del controlador)
            const internalId = internalUserId;
            if (!internalId) {
                 console.warn(`Advertencia: No se pudo obtener el ID del usuario interno para la auditor칤a (updateByInitCode ${initCode}).`);
                 // Considera lanzar un error si la auditor칤a es estrictamente necesaria
                 // throw new Error("El ID del usuario interno es requerido para la auditor칤a.");
            }

            // 4. Realizar la actualizaci칩n usando Init_Code en el 'where'
            const [rowsUpdated] = await Assignment.update(data, {
                where: { Init_Code: initCode }
            });

            // 5. Si no se actualiz칩 nada (quiz치s los datos eran iguales), retornar null
            if (rowsUpdated === 0) {
                console.log(`No se realizaron cambios en la asignaci칩n con Init_Code ${initCode}.`);
                return null; // Sigue el patr칩n del ejemplo original
            }

            // 6. Obtener la asignaci칩n actualizada para devolverla usando el nombre de la clase
            const updatedAssignment = await AssignmentModel.getByInitCode(initCode); // <--- CORRECCI칍N AQU칈

            // 7. Registrar en auditor칤a si tenemos el ID del usuario
            if (internalId) {
                await AuditModel.registerAudit(
                    internalId,
                    "UPDATE",
                    "Assignment",
                    `El usuario interno ${internalId} actualiz칩 la asignaci칩n asociada al caso ${initCode} (ID Asignaci칩n: ${assignment.Assignment_ID})`
                );
            }

            // 8. Devolver la asignaci칩n actualizada
            return updatedAssignment;

        } catch (error) {
            // Capturar y relanzar el error para manejo en el controlador
            console.error(`Error updating assignment by Init_Code ${initCode}:`, error);
            // La l칤nea 295 original estaba aqu칤, relanzando el error
            throw new Error(`Error updating assignment by Init_Code: ${error.message}`);
        }
    }

    static async delete(id, internalUser) {
        try {
            const assignment = await this.getById(id);
            if (!assignment) return null;

            const internalId = internalUser || getUserId();
            
            await Assignment.destroy({ where: { Assignment_Id: id } });

            // 游댳 Registrar en Audit que un usuario interno elimin칩 una asignaci칩n
            await AuditModel.registerAudit(
                internalId, 
                "DELETE",
                "Assignment",
                `El usuario interno ${internalId} elimin칩 la asignaci칩n con ID ${id}`
            );

            return assignment;
        } catch (error) {
            throw new Error(`Error deleting assignment: ${error.message}`);
        }
    }
}

